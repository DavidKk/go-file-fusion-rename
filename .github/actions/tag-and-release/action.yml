name: "Tag and Release"
description: "Automatically create version tag and GitHub release"

inputs:
  github-token:
    description: "GitHub token"
    required: true
  version-bump:
    description: "Version bump type"
    required: false
    default: "patch"
  artifacts:
    description: "Comma-separated list of artifacts to include in release"
    required: true
  release-type:
    description: "Release type: auto only"
    required: false
    default: "auto"
  use-hash:
    description: "Whether to use hash for version"
    required: false
    default: "true"

outputs:
  tag:
    description: "Created tag"
    value: ${{ steps.outputs.outputs.tag }}
  changelog:
    description: "Generated changelog"
    value: ${{ steps.outputs.outputs.changelog }}
  should-release:
    description: "Whether release should proceed"
    value: ${{ steps.outputs.outputs.should_release }}
  timestamp:
    description: "Build timestamp"
    value: ${{ steps.outputs.outputs.timestamp }}

runs:
  using: "composite"
  steps:
    - name: Get commit hash and timestamp
      id: hash
      shell: bash
      run: |
        # Get commit hash
        echo "short_sha=${GITHUB_SHA:0:7}" >> $GITHUB_OUTPUT
        echo "full_sha=$GITHUB_SHA" >> $GITHUB_OUTPUT

        # Get timestamp in UTC format (YYYYMMDD-HHMMSS)
        timestamp=$(date -u +"%Y%m%d-%H%M%S")
        echo "timestamp=$timestamp" >> $GITHUB_OUTPUT

        # Create unique version suffix with timestamp and hash
        version_suffix="${timestamp}.${GITHUB_SHA:0:7}"
        echo "version_suffix=$version_suffix" >> $GITHUB_OUTPUT

        echo "Generated version suffix: $version_suffix"

    - name: Check existing tag
      id: existing_tag
      shell: bash
      run: |
        existing_tag=$(git tag --points-at HEAD)
        if [ -n "$existing_tag" ]; then
          echo "tag=$existing_tag" >> $GITHUB_OUTPUT
          echo "has_tag=true" >> $GITHUB_OUTPUT
        else
          echo "tag=" >> $GITHUB_OUTPUT
          echo "has_tag=false" >> $GITHUB_OUTPUT
        fi

    - name: Check version strategy
      id: version_check
      shell: bash
      run: |
        set -e

        # è·å–æ‰€æœ‰æ ‡ç­¾
        echo "Fetching all tags..."
        git fetch --tags || true

        # æ˜¾ç¤ºå½“å‰æ‰€æœ‰æ ‡ç­¾
        echo "Current tags:"
        git tag -l || echo "No tags found"

        # è·å–æœ€æ–°çš„æ­£å¼ç‰ˆæœ¬æ ‡ç­¾ï¼ˆä¸åŒ…å«alphaï¼‰
        echo "Searching for formal version tags..."
        latest_formal_tag=$(git tag -l | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | sort -V | tail -1 || echo "")
        echo "Latest formal tag found: '${latest_formal_tag}'"

        if [ -z "$latest_formal_tag" ]; then
          # æ²¡æœ‰ä»»ä½•æ­£å¼ç‰ˆæœ¬æ ‡ç­¾ï¼Œä½¿ç”¨åˆå§‹ç‰ˆæœ¬
          echo "No formal tags found, using initial version"
          echo "next_version=v1.0.0" >> $GITHUB_OUTPUT
          echo "strategy=initial" >> $GITHUB_OUTPUT
          echo "latest_formal_tag=" >> $GITHUB_OUTPUT
        else
          # æ£€æŸ¥æ˜¯å¦å·²æœ‰å¯¹åº”çš„alphaç‰ˆæœ¬
          echo "Checking for existing alpha versions of ${latest_formal_tag}..."
          alpha_tag_exists=$(git tag -l | grep -E "^${latest_formal_tag}-alpha\\." | head -1 || echo "")
          echo "Alpha tag found: '${alpha_tag_exists}'"
          
          if [ -n "$alpha_tag_exists" ]; then
            # å·²æœ‰alphaç‰ˆæœ¬ï¼Œè¯´æ˜å½“å‰ç‰ˆæœ¬è¿˜æœªæ­£å¼å‘å¸ƒï¼Œä¿æŒç‰ˆæœ¬ä¸å˜
            echo "Alpha version exists, keeping current version"
            echo "next_version=$latest_formal_tag" >> $GITHUB_OUTPUT
            echo "strategy=keep_current" >> $GITHUB_OUTPUT
          else
            # æ²¡æœ‰alphaç‰ˆæœ¬ï¼Œè¯´æ˜æœ€æ–°æ­£å¼ç‰ˆæœ¬å·²å‘å¸ƒï¼Œéœ€è¦+1
            echo "No alpha version found, incrementing version"
            version_without_v=${latest_formal_tag#v}
            IFS='.' read -r major minor patch <<< "$version_without_v"
            next_patch=$((patch + 1))
            next_version="v${major}.${minor}.${next_patch}"
            echo "Incremented version: $next_version"
            echo "next_version=$next_version" >> $GITHUB_OUTPUT
            echo "strategy=increment" >> $GITHUB_OUTPUT
          fi
          echo "latest_formal_tag=$latest_formal_tag" >> $GITHUB_OUTPUT
        fi

    - name: Set outputs
      id: outputs
      shell: bash
      run: |
        if [ "${{ steps.existing_tag.outputs.has_tag }}" = "true" ]; then
          # å¦‚æœå·²æœ‰TAGï¼Œç›´æ¥ä½¿ç”¨
          version_tag="${{ steps.existing_tag.outputs.tag }}"
          changelog="Release using existing tag ${{ steps.existing_tag.outputs.tag }}"
        else
          # ä½¿ç”¨æ™ºèƒ½ç‰ˆæœ¬ç­–ç•¥ï¼ŒåŒ…å«æ—¶é—´æˆ³
          base_version="${{ steps.version_check.outputs.next_version }}"
          version_tag="${base_version}-alpha.${{ steps.hash.outputs.version_suffix }}"
          
          case "${{ steps.version_check.outputs.strategy }}" in
            "initial")
              changelog="Initial version ${base_version} (first release)"
              ;;
            "increment")
              changelog="Auto-increment to ${base_version} (previous version ${{ steps.version_check.outputs.latest_formal_tag }} was already released)"
              ;;
            "keep_current")
              changelog="Keep current version ${base_version} (no formal release yet for this version)"
              ;;
            *)
              changelog="Alpha release ${version_tag}"
              ;;
          esac
        fi

        echo "tag=${version_tag}" >> $GITHUB_OUTPUT
        echo "changelog=${changelog}" >> $GITHUB_OUTPUT
        echo "should_release=true" >> $GITHUB_OUTPUT
        echo "hash=${{ steps.hash.outputs.short_sha }}" >> $GITHUB_OUTPUT
        echo "timestamp=${{ steps.hash.outputs.timestamp }}" >> $GITHUB_OUTPUT

    - name: Download artifacts
      if: steps.outputs.outputs.should_release == 'true'
      uses: actions/download-artifact@v4
      with:
        path: ./release

    - name: Debug artifacts
      if: steps.outputs.outputs.should_release == 'true'
      shell: bash
      run: |
        echo "Listing downloaded artifacts:"
        find ./release -type f -name "*.zip" | head -20
        echo "Checking all ZIP files:"

        # Check Linux ZIP
        if [ -f "./release/file-fusion-rename-linux/file-fusion-rename-linux.zip" ]; then
          echo "âœ… Linux ZIP file found"
          ls -la "./release/file-fusion-rename-linux/file-fusion-rename-linux.zip"
        else
          echo "âŒ Linux ZIP file not found"
        fi

        # Check Windows ZIP
        if [ -f "./release/file-fusion-rename-windows/file-fusion-rename-windows.zip" ]; then
          echo "âœ… Windows ZIP file found"
          ls -la "./release/file-fusion-rename-windows/file-fusion-rename-windows.zip"
        else
          echo "âŒ Windows ZIP file not found"
        fi

        # Check macOS Intel ZIP
        if [ -f "./release/file-fusion-rename-macos-intel/file-fusion-rename-macos-intel.zip" ]; then
          echo "âœ… macOS Intel ZIP file found"
          ls -la "./release/file-fusion-rename-macos-intel/file-fusion-rename-macos-intel.zip"
        else
          echo "âŒ macOS Intel ZIP file not found"
        fi

        # Check macOS ARM64 ZIP
        if [ -f "./release/file-fusion-rename-macos-arm64/file-fusion-rename-macos-arm64.zip" ]; then
          echo "âœ… macOS ARM64 ZIP file found"
          ls -la "./release/file-fusion-rename-macos-arm64/file-fusion-rename-macos-arm64.zip"
        else
          echo "âŒ macOS ARM64 ZIP file not found"
        fi

        # Check macOS App Bundle ZIP
        if [ -f "./release/File-Fusion-Rename-macOS-App/File-Fusion-Rename-macOS-App.zip" ]; then
          echo "âœ… macOS App Bundle ZIP file found"
          ls -la "./release/File-Fusion-Rename-macOS-App/File-Fusion-Rename-macOS-App.zip"
        else
          echo "âŒ macOS App Bundle ZIP file not found"
        fi

    - name: Create GitHub Release
      if: steps.outputs.outputs.should_release == 'true' && steps.outputs.outputs.tag != ''
      uses: softprops/action-gh-release@v2
      with:
        tag_name: ${{ steps.outputs.outputs.tag }}
        name: Release ${{ steps.outputs.outputs.tag }}
        body: |
          ## ğŸš€ Release ${{ steps.outputs.outputs.tag }}

          ### ğŸ“‹ Release Info
          - **Release Type**: è‡ªåŠ¨å‘å¸ƒ (Auto)
          - **Commit Hash**: ${{ steps.outputs.outputs.hash }}
          - **Build Timestamp**: ${{ steps.outputs.outputs.timestamp }}
          - **Version Strategy**: æ—¶é—´æˆ³+å“ˆå¸Œå€¼ç‰ˆæœ¬

          ### âœ¨ What's New
          ${{ steps.outputs.outputs.changelog }}

          ### ğŸ“¦ Downloads
          - **Linux**: file-fusion-rename-linux.zip
          - **Windows**: file-fusion-rename-windows.zip
          - **macOS (Intel)**: file-fusion-rename-macos-intel.zip
          - **macOS (Apple Silicon)**: file-fusion-rename-macos-arm64.zip
          - **macOS App Bundle**: File-Fusion-Rename-macOS-App.zip (åŒ…å« .app åº”ç”¨ç¨‹åºåŒ…)

          ### ğŸ”§ Installation
          **All Binary Files (ZIP Format):**
          1. Download the appropriate ZIP file for your platform
          2. Extract the ZIP file to get the binary
          3. Make it executable (Linux/macOS): `chmod +x file-fusion-rename-*`
          4. Run the application

          **macOS App Bundle:**
          1. Download `File-Fusion-Rename-macOS-App.zip`
          2. Extract the ZIP file to get `File Fusion Rename.app`
          3. Drag to Applications folder
          4. Double-click to run

          ### ğŸ“ Changelog
          For detailed changes, see the commit history.
        files: |
          ./release/file-fusion-rename-linux/file-fusion-rename-linux.zip
          ./release/file-fusion-rename-windows/file-fusion-rename-windows.zip
          ./release/file-fusion-rename-macos-intel/file-fusion-rename-macos-intel.zip
          ./release/file-fusion-rename-macos-arm64/file-fusion-rename-macos-arm64.zip
          ./release/File-Fusion-Rename-macOS-App/File-Fusion-Rename-macOS-App.zip
        draft: false
        prerelease: true
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}
