name: "Tag and Release"
description: "Automatically create version tag and GitHub release"

inputs:
  github-token:
    description: "GitHub token"
    required: true
  version-bump:
    description: "Version bump type"
    required: false
    default: "patch"
  artifacts:
    description: "Comma-separated list of artifacts to include in release"
    required: true
  release-type:
    description: "Release type: auto only"
    required: false
    default: "auto"
  use-hash:
    description: "Whether to use hash for version"
    required: false
    default: "true"

outputs:
  tag:
    description: "Created tag"
    value: ${{ steps.outputs.outputs.tag }}
  changelog:
    description: "Generated changelog"
    value: ${{ steps.outputs.outputs.changelog }}
  should-release:
    description: "Whether release should proceed"
    value: ${{ steps.outputs.outputs.should_release }}

runs:
  using: "composite"
  steps:
    - name: Get commit hash
      id: hash
      shell: bash
      run: |
        echo "short_sha=${GITHUB_SHA:0:7}" >> $GITHUB_OUTPUT
        echo "full_sha=$GITHUB_SHA" >> $GITHUB_OUTPUT

    - name: Check existing tag
      id: existing_tag
      shell: bash
      run: |
        existing_tag=$(git tag --points-at HEAD)
        if [ -n "$existing_tag" ]; then
          echo "tag=$existing_tag" >> $GITHUB_OUTPUT
          echo "has_tag=true" >> $GITHUB_OUTPUT
        else
          echo "tag=" >> $GITHUB_OUTPUT
          echo "has_tag=false" >> $GITHUB_OUTPUT
        fi

    - name: Check version strategy
      id: version_check
      shell: bash
      run: |
        set -e

        # 获取所有标签
        echo "Fetching all tags..."
        git fetch --tags || true

        # 显示当前所有标签
        echo "Current tags:"
        git tag -l || echo "No tags found"

        # 获取最新的正式版本标签（不包含alpha）
        echo "Searching for formal version tags..."
        latest_formal_tag=$(git tag -l | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | sort -V | tail -1 || echo "")
        echo "Latest formal tag found: '${latest_formal_tag}'"

        if [ -z "$latest_formal_tag" ]; then
          # 没有任何正式版本标签，使用初始版本
          echo "No formal tags found, using initial version"
          echo "next_version=v1.0.0" >> $GITHUB_OUTPUT
          echo "strategy=initial" >> $GITHUB_OUTPUT
          echo "latest_formal_tag=" >> $GITHUB_OUTPUT
        else
          # 检查是否已有对应的alpha版本
          echo "Checking for existing alpha versions of ${latest_formal_tag}..."
          alpha_tag_exists=$(git tag -l | grep -E "^${latest_formal_tag}-alpha\\." | head -1 || echo "")
          echo "Alpha tag found: '${alpha_tag_exists}'"
          
          if [ -n "$alpha_tag_exists" ]; then
            # 已有alpha版本，说明当前版本还未正式发布，保持版本不变
            echo "Alpha version exists, keeping current version"
            echo "next_version=$latest_formal_tag" >> $GITHUB_OUTPUT
            echo "strategy=keep_current" >> $GITHUB_OUTPUT
          else
            # 没有alpha版本，说明最新正式版本已发布，需要+1
            echo "No alpha version found, incrementing version"
            version_without_v=${latest_formal_tag#v}
            IFS='.' read -r major minor patch <<< "$version_without_v"
            next_patch=$((patch + 1))
            next_version="v${major}.${minor}.${next_patch}"
            echo "Incremented version: $next_version"
            echo "next_version=$next_version" >> $GITHUB_OUTPUT
            echo "strategy=increment" >> $GITHUB_OUTPUT
          fi
          echo "latest_formal_tag=$latest_formal_tag" >> $GITHUB_OUTPUT
        fi

    - name: Set outputs
      id: outputs
      shell: bash
      run: |
        if [ "${{ steps.existing_tag.outputs.has_tag }}" = "true" ]; then
          # 如果已有TAG，直接使用
          version_tag="${{ steps.existing_tag.outputs.tag }}"
          changelog="Release using existing tag ${{ steps.existing_tag.outputs.tag }}"
        else
          # 使用智能版本策略
          base_version="${{ steps.version_check.outputs.next_version }}"
          version_tag="${base_version}-alpha.${{ steps.hash.outputs.short_sha }}"
          
          case "${{ steps.version_check.outputs.strategy }}" in
            "initial")
              changelog="Initial version ${base_version} (first release)"
              ;;
            "increment")
              changelog="Auto-increment to ${base_version} (previous version ${{ steps.version_check.outputs.latest_formal_tag }} was already released)"
              ;;
            "keep_current")
              changelog="Keep current version ${base_version} (no formal release yet for this version)"
              ;;
            *)
              changelog="Alpha release ${version_tag}"
              ;;
          esac
        fi

        echo "tag=${version_tag}" >> $GITHUB_OUTPUT
        echo "changelog=${changelog}" >> $GITHUB_OUTPUT
        echo "should_release=true" >> $GITHUB_OUTPUT
        echo "hash=${{ steps.hash.outputs.short_sha }}" >> $GITHUB_OUTPUT

    - name: Download artifacts
      if: steps.outputs.outputs.should_release == 'true'
      uses: actions/download-artifact@v4
      with:
        path: ./release

    - name: Debug artifacts
      if: steps.outputs.outputs.should_release == 'true'
      shell: bash
      run: |
        echo "Listing downloaded artifacts:"
        find ./release -type f -name "*" | head -20
        echo "Checking macOS app bundle:"
        ls -la "./release/File-Fusion-Rename-macOS-App/" || echo "macOS app bundle directory not found"
        if [ -f "./release/File-Fusion-Rename-macOS-App/File-Fusion-Rename-macOS-App.zip" ]; then
          echo "macOS app ZIP file found"
          ls -la "./release/File-Fusion-Rename-macOS-App/File-Fusion-Rename-macOS-App.zip"
        else
          echo "macOS app ZIP file not found"
        fi

    - name: Create GitHub Release
      if: steps.outputs.outputs.should_release == 'true' && steps.outputs.outputs.tag != ''
      uses: softprops/action-gh-release@v2
      with:
        tag_name: ${{ steps.outputs.outputs.tag }}
        name: Release ${{ steps.outputs.outputs.tag }}
        body: |
          ## 🚀 Release ${{ steps.outputs.outputs.tag }}

          ### 📋 Release Info
          - **Release Type**: 自动发布 (Auto)
          - **Commit Hash**: ${{ steps.outputs.outputs.hash }}
          - **Version Strategy**: 哈希值版本

          ### ✨ What's New
          ${{ steps.outputs.outputs.changelog }}

          ### 📦 Downloads
          - **Linux**: file-fusion-rename-linux
          - **Windows**: file-fusion-rename-windows.exe  
          - **macOS (Intel)**: file-fusion-rename-macos-intel
          - **macOS (Apple Silicon)**: file-fusion-rename-macos-arm64
          - **macOS App Bundle**: File-Fusion-Rename-macOS-App.zip (包含 .app 应用程序包)

          ### 🔧 Installation
          **Binary Files:**
          1. Download the appropriate binary for your platform
          2. Make it executable (Linux/macOS): `chmod +x file-fusion-rename-*`
          3. Run the application

          **macOS App Bundle:**
          1. Download `File-Fusion-Rename-macOS-App.zip`
          2. Extract the ZIP file to get `File Fusion Rename.app`
          3. Drag to Applications folder
          4. Double-click to run

          ### 📝 Changelog
          For detailed changes, see the commit history.
        files: |
          ./release/file-fusion-rename-linux/file-fusion-rename-linux
          ./release/file-fusion-rename-windows/file-fusion-rename-windows.exe
          ./release/file-fusion-rename-macos-intel/file-fusion-rename-macos-intel
          ./release/file-fusion-rename-macos-arm64/file-fusion-rename-macos-arm64
          ./release/File-Fusion-Rename-macOS-App/File-Fusion-Rename-macOS-App.zip
        draft: false
        prerelease: true
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}
